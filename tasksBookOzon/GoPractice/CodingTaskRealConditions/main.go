package main

// Есть набор урлов.
func main() {
	var urls = []string{
		"http://ozon.ru",
		"https://ozon.ru",
		"http://google.com",
		"http://somesite.com",
		"http://non-existent.domain.tld",
		"https://ya.ru",
		"http://ya.ru",
		"http://ёёёё",
	}
}

/*Напишите программу, которая:
//TODO 1. Поочередно выполнит http запросы по предложенному списку ссылок
в случае получения http-кода ответа на запрос "200 OK" печатаем на экране "адрес url-ok"
в случае получения http-кода ответа на запрос отличного от "200 OK" либо в случае
ошибки печатаем на экране "адрес url - not ok"
//TODO 2. Модифицируйте программу таким образом, чтобы использовались каналы для
коммуникации основного потока с горутинами. Пример:
-Запросы по списку выполняются в горутинах.
-Печать результатов на экран происходит в основном потоке
//TODO 3. Модифицируйте программу таким образом, чтобы нигде не использовалась длина
слайса урлов. Считайте, что урлы приходят из внешнего источника. Сколько их будет
заранее - неизвестно. Предложите идиоматичный вариант, как ваша программа будет
узнавать об окончании списка и передавать сигнал об окончании действий далее.
//TODO 4. (необязательно, можно обсудить устно, чтобы убедиться, что кандидат понимает идею
контекста, либо предложить как домашнее задание) Модифицируйте программу таким
образом, что бы при получении 2 первых ответов с "200 OK" остальные запросы штатно
прерывались.
P.S.(либо atomic либо отдельная горутина ?)
При этом необходимо напечатать на экране сообщение о завершении запроса.
5. (необязательно, можно обсудить устно) Предложите отрефакторить код. Какие тесты
кандидат написал бы к этому коду?
Предложите написать код теста и интерфейсы, для которых будут генериться моки. (Как
показывает практика это самая сложная часть задачи)
Ответ
17 грейд
Написал синхронное решение, которое идет последовательно и выполняет http-запрос
18 грейд
Написал решение с использованием канала (куда отправляются ссылки для скачивания),
горутин (воркеров), которые выполняют запросы и sync.WaitGroup для ожидания
завершения.
Может реализовать остановку выполнения воркеров через context или управляющий
канал.
19 грейд
Может написать решение, чтобы ограничивать количество исходящих запросов.
Может самостоятельно написать моки.

Дополнительные вопросы
Первый пункт очень прост и хорош для разминки кандидата, ознакомления с сервисов,
чтобы кандидат запустил код, посмотрел как работает. По каждому пункту можно
дополнительно обсудить использованные им примитивы, почему выбрано то или иное
решение.
Например:
-какие вообще есть примитивы синхронизации в go, как их можно использовать
-как используются закрытые каналы
-что будет если писать или читать в закрытый канал
-как сделать счетчик, агрегирующий информацию из разных горутин (либо atomic либо
-отдельная горутина)
-как использовать контекст */
