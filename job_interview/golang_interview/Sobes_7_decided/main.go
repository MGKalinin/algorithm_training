package main

//===========================================================
//Задача 1_workerPool_semafore
//Составьте правильный запрос, который выдает страну и количество студентов из таблицы students, где количество студентов больше 10 и они (студенты) не из Китая(China). Таблица students (id, name, country)
//SELECT
//country,
//COUNT(*)
//FROM students
//WHERE country != 'China'
//GROUP BY country
//HAVING COUNT(*) > 10;
//===========================================================
//
//===========================================================
//Задача 2
//Будет ошибка что все горутины заблокированы. Какие горутины будут заблокированы? И почему?
//===========================================================

//package main
//import "fmt"
//
//func main() {
//	//ch := make(chan int) // не буф.канал
//	ch := make(chan int, 1_workerPool_semafore) // 2. или добавить буфер
//	//ch <- 1_workerPool_semafore //main заблокирована, ожидает получателя
//	go func() {
//		fmt.Println(<-ch) // горутина не запустится-main заблокирована, не дошла до её создания
//	}()
//	//ch <- 1_workerPool_semafore // 1_workerPool_semafore.запустить получателя до отправки в канал
//}

//===========================================================
//Задача 3
//1_workerPool_semafore. ЫЫЫхыхы (Было именно так, а имелось ввиду "Что выведется?")
//===========================================================
//package main
//import (
//	"fmt"
//	"math"
//)
//
//func main() {
//	c := []string{"A", "B", "D", "E"}
//	b := c[1_workerPool_semafore:2] // "B"
//	b = append(b, "TT")
//	fmt.Println(c) // "A", "B", "D", "E" : хуй -будет [A B TT E]: c и b ссылаются на один и тот же базовый массив
//	/* b имеет:Длину: 1_workerPool_semafore (элемент с индексом 1_workerPool_semafore - "B")
//	Емкость: 3 (потому что в исходном массиве после "B" есть еще 2 элемента: "D" и "E")
//	Поскольку у b есть свободная емкость (2 свободных места), append добавит "TT" в тот же базовый массив
//	Это заменит следующий элемент в исходном массиве:
//	Было: ["A", "B", "D", "E"]
//	Стало: ["A", "B", "TT", "E"]*/
//	fmt.Println(b) // "B", "TT"
//}

//
//===========================================================
//Задача 4
//1_workerPool_semafore. Что выведется?
//===========================================================

import (
	"fmt"
	"math"
)

func main() {
	x := 2.0
	y := 3.0

	result := math.Pow(x, y)

	fmt.Println("%f ^ %f = %f\n", x, y, result)
	//%f ^ %f = %f
	//2 3 8
	//fmt.Println:Не поддерживает форматирование
	// Просто выводит все аргументы через пробел
	//Специальные символы (как %f) не интерпретируются
	//Почему числа выводятся без десятичной части:
	//Для значений типа float функция fmt.Println по умолчанию использует формат %g
	//%g автоматически выбирает между %f и %e, убирая лишние нули
	//Поэтому 2.0 выводится как "2", 3.0 как "3", а 8.0 как "8"

	//Используйте fmt.Printf для форматированного вывода:
	//fmt.Printf("%.0f ^ %.0f = %.0f\n", x, y, result)
	//Вывод:
	//2 ^ 3 = 8
}
