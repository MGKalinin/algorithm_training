package main

import (
	"fmt"
	"net/http"
	"sync"
)

// TODO –ø–∏—Å–∞—Ç—å –∫–æ–¥ –≤ –ø–µ—Å–æ—á–Ω–∏—Ü–µ
// –û–∑–æ–Ω –ü–ª–∞—Ç—Ñ–æ—Ä–º–∞
//
// –î–∞—Ç–∞: —Ñ–µ–≤—Ä–∞–ª—å 2025
// –ì—Ä–µ–π–¥: –º–∏–¥–ª
// #–û–∑–æ–Ω
//
// –ó–∞–¥–∞—á–∏ –ø—Ä–∏—Å–ª–∞–Ω—ã —É—á–∞—Å—Ç–Ω–∏–∫–æ–º —Å–æ–æ–±—â–µ—Å—Ç–≤–∞. –ö–∞–∫ –ø—Ä–∏—Å–ª–∞—Ç—å —Å–≤–æ—é –∑–∞–¥–∞—á—É —á–∏—Ç–∞–π—Ç–µ —Ç—É—Ç.
//
// 1Ô∏è‚É£ –°–∫—Ä–∏–Ω–∏–Ω–≥
// üëâ –î–∞–Ω–æ x, –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ x —Å—Ç–µ–ø–µ–Ω—å—é –¥–≤–æ–π–∫–∏.
// üí° –†–µ—à–µ–Ω–∏–µ: x & (x - 1) == 0 ‚Äì –µ—Å–ª–∏ –≤—ã–ø–æ–ª–Ω—è–µ—Ç—Å—è, –∑–Ω–∞—á–∏—Ç x —Å—Ç–µ–ø–µ–Ω—å –¥–≤–æ–π–∫–∏.
// 2Ô∏è‚É£ –¢–µ—Ö–Ω–∏—á–µ—Å–∫–æ–µ —Å–æ–±–µ—Å–µ–¥–æ–≤–∞–Ω–∏–µ
// üìå –ó–∞–¥–∞—á–∞ 1:
// –î–∞–Ω —Å–ø–∏—Å–æ–∫ URL, –Ω—É–∂–Ω–æ —Å–∏–Ω—Ö—Ä–æ–Ω–Ω–æ –ø—Ä–æ–π—Ç–∏—Å—å –ø–æ –Ω–µ–º—É –∏:
// ‚úÖ –í—ã–≤–µ—Å—Ç–∏ "–û–ö", –µ—Å–ª–∏ —Å—Ç–∞—Ç—É—Å-–∫–æ–¥ 200.
// ‚ùå –í—ã–≤–µ—Å—Ç–∏ "–Ω–µ –û–ö", –µ—Å–ª–∏ —Å—Ç–∞—Ç—É—Å-–∫–æ–¥  –Ω–µ 200 –∏–ª–∏ –ø—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞.
//
// üìå –ó–∞–¥–∞—á–∞ 2:
// –¢–∞ –∂–µ –ø—Ä–æ–≤–µ—Ä–∫–∞, –Ω–æ —Ç–µ–ø–µ—Ä—å –∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–æ/–≤ –ø–∞—Ä–∞–ª–ª–µ–ª—å, –ø—Ä–∏ —ç—Ç–æ–º –Ω–∏—á–µ–≥–æ –Ω–µ –¥–æ–ª–∂–Ω–æ –ø–æ—Ç–µ—Ä—è—Ç—å—Å—è.
func main() {
	urls := []string{
		"https://yandex.ru",
		"https://habr.com",
		"https://lenta.ru",
		"https://ria.ru",
		"https://tass.ru",
		"https://ozone.ru",
	}

	// TO DO 1.semaphore
	//channel for results of request
	//result := make(chan string, len(urls))
	//
	////semafore channel
	//semaf := make(chan struct{}, 3)
	//wg := sync.WaitGroup{}
	//
	//for _, url := range urls {
	//	wg.Add(1)
	//	go func(u string) {
	//		defer wg.Done()
	//		semaf <- struct{}{}
	//		defer func() { <-semaf }()
	//		//request by url
	//		req, err := http.Get(u)
	//		if err != nil {
	//			result <- fmt.Sprintf("%s: –Ω–µ ook", u)
	//			return
	//		}
	//		defer req.Body.Close()
	//		if req.StatusCode == http.StatusOK {
	//			result <- fmt.Sprintf("%s: ok", u)
	//		} else {
	//			result <- fmt.Sprintf("%s: –Ω–µ –û–ö", u)
	//		}
	//
	//	}(url)
	//}
	//go func() {
	//	wg.Wait()
	//	close(result)
	//}()
	//for val := range result {
	//	fmt.Println(val)
	//}

	// TODO 2.worker pool
	// https://go.dev/play/p/rbFgFYMKk6m
	const workers = 3
	n := len(urls)

	//channel for tasks
	tasks := make(chan string, n)
	//channel for results
	result := make(chan string, n)

	wg := sync.WaitGroup{}

	//run the workers
	for i := 1; i < workers; i++ {
		wg.Add(1)
		go worker(tasks, result, &wg)
	}

	//run cicle by slice and recive the answer
	for _, url := range urls {
		tasks <- url
	}
	close(tasks)

	go func() {
		wg.Wait()
		close(result)
	}()

	//read the answer
	for ans := range result {
		fmt.Println(ans)
	}
}

// worker for requests
func worker(tasks <-chan string, result chan<- string, wg *sync.WaitGroup) {
	defer wg.Done()

	for url := range tasks {
		req, err := http.Get(url)
		if err != nil {
			result <- fmt.Sprintf("not ook")
			continue
		}

		defer req.Body.Close()
		if req.StatusCode == http.StatusOK {
			result <- fmt.Sprintf("ok")
		} else {
			result <- fmt.Sprintf("not ok")
		}
	}
}

// TODO 3.–∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –∫–æ–Ω—Ç–µ–∫—Å—Ç –æ—Ç–º–µ–Ω—ã –ø–æ—Å–ª–µ –¥–≤—É—Ö 200 –æ–∫
