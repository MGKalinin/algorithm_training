package main

import (
	"fmt"
	"net/http"
	"sync"
)

// Есть набор урлов.
func main() {
	var urls = []string{
		"http://ozon.ru",
		"https://ozon.ru",
		"http://google.com",
		"http://somesite.com",
		"http://non-existent.domain.tld",
		"https://ya.ru",
		"http://ya.ru",
		"http://ёёёё",
	}

	/*
	   Напишите программу, которая:
	   1. Поочередно выполнит http запросы по предложенному списку ссылок
	   •в случае получения http-кода ответа на запрос "200 OK" печатаем на экране "адрес url -
	   ok"
	   •в случае получения http-кода ответа на запрос отличного от "200 OK" либо в случае
	   ошибки печатаем на экране "адрес url - not ok"
	   2. Модифицируйте программу таким образом, чтобы использовались каналы для
	   коммуникации основного потока с горутинами. Пример:
	   •Запросы по списку выполняются в горутинах.
	   •Печать результатов на экран происходит в основном потоке
	   3. Модифицируйте программу таким образом, чтобы нигде не использовалась длина
	   слайса урлов. Считайте, что урлы приходят из внешнего источника. Сколько их будет
	   заранее - неизвестно. Предложите идиоматичный вариант, как ваша программа будет
	   узнавать об окончании списка и передавать сигнал об окончании действий далее.
	   4. (необязательно, можно обсудить устно, чтобы убедиться, что кандидат понимает идею
	   контекста, либо предложить как домашнее задание) Модифицируйте программу таким
	   образом, что бы при получении 2 первых ответов с "200 OK" остальные запросы штатно
	   прерывались.
	   При этом необходимо напечатать на экране сообщение о завершении запроса.
	   5. (необязательно, можно обсудить устно) Предложите отрефакторить код. Какие тесты
	   кандидат написал бы к этому коду?
	   Предложите написать код теста и интерфейсы, для которых будут генериться моки. (Как
	   показывает практика это самая сложная часть задачи)
	*/

	/*
	   1. Поочередно выполнит http запросы по предложенному списку ссылок
	   •в случае получения http-кода ответа на запрос "200 OK" печатаем на экране "адрес url -
	   ok"
	   •в случае получения http-кода ответа на запрос отличного от "200 OK" либо в случае
	   ошибки печатаем на экране "адрес url - not ok" */

	//	for _, url := range urls {
	//		GetAnswer(url)
	//	}
	//}
	//
	//// GetAnswer функция возвращает результат запроса по адресу
	//func GetAnswer(url string) {
	//	resp, err := http.Get(url)
	//	if err != nil {
	//		fmt.Printf("адрес: %s - not ok (ошибка: %v)\n", url, err) // обработка например не существующий адрес
	//		return                                                    // продолжаем по перечню url
	//	}
	//	defer resp.Body.Close() // закрываем тело запроса
	//
	//	if resp.StatusCode == http.StatusOK {
	//		fmt.Printf("адрес: %s - ok\n", url)
	//	} else {
	//		fmt.Printf("адрес: %s - not ok\n", url)
	//	}
	//}

	/*
	   2. Модифицируйте программу таким образом, чтобы использовались каналы для
	   	   коммуникации основного потока с горутинами. Пример:
	   	   •Запросы по списку выполняются в горутинах.
	   	   •Печать результатов на экран происходит в основном потоке
	*/
	//var wg sync.WaitGroup
	//result := make(chan string) //результирующий канал
	//
	//for _, url := range urls {
	//	wg.Add(1) //добавляем горутину
	//	go func(u string) {
	//		defer wg.Done() //уменьшаем счётчик при выходе
	//
	//		resp, err := http.Get(u)
	//		if err != nil {
	//			// обработка например не существующий адрес
	//			result <- fmt.Sprintf("адрес: %s - not ok (ошибка: %v)", u, err)
	//			return // продолжаем по перечню url
	//		}
	//		defer resp.Body.Close() // закрываем тело запроса
	//
	//		if resp.StatusCode == http.StatusOK {
	//			result <- fmt.Sprintf("адрес: %s - ok", u)
	//		} else {
	//			result <- fmt.Sprintf("адрес: %s - not ok", u)
	//		}
	//
	//	}(url)
	//}
	////закрыть канал, дождаться завершения горутин
	//go func() {
	//	wg.Wait()     //сначала ждём завершения
	//	close(result) //закрываем канал
	//}()
	////выводим полученный результат
	//for res := range result {
	//	fmt.Println(res)
	//}

	/*
		3. Модифицируйте программу таким образом, чтобы нигде не использовалась длина
		слайса урлов. Считайте, что урлы приходят из внешнего источника. Сколько их будет
		заранее - неизвестно. Предложите идиоматичный вариант, как ваша программа будет
		узнавать об окончании списка и передавать сигнал об окончании действий далее.
	*/ //TO DO: и ещё добавить worker pool

	// Считайте, что урлы приходят из внешнего источника. - этот пункт имитируем путём чтения из канала-
	//якобы в который приходят url
	//inputUrls := make(chan string)
	//resultUrl := make(chan string) //канал чтения результатов запроса
	//var wg sync.WaitGroup
	//
	////запуск записи в канал url
	//go func() {
	//	for _, url := range urls { // в реальности это чтение из внешнего источника- API, файл
	//		inputUrls <- url
	//	}
	//	close(inputUrls) // закрываем по окончании данных
	//}()
	//
	//// запустить worker в заданном количестве
	//count := 5 // количество worker
	//for i := 0; i < count; i++ {
	//	wg.Add(1)
	//	go worker(inputUrls, resultUrl, &wg)
	//}
	//
	//// ждём горутины, закрываем канал
	//go func() {
	//	wg.Wait()
	//	close(resultUrl)
	//}()
	//
	//// напечатать результат
	//for res := range resultUrl {
	//	fmt.Println(res)
	//}
	//}

	//// worker функция обработаки url
	//func worker(inputUrls <-chan string, resultUrl chan<- string, wg *sync.WaitGroup) {
	//	defer wg.Done()
	//
	//	for url := range inputUrls {
	//		resp, err := http.Get(url)
	//		if err != nil {
	//			resultUrl <- fmt.Sprintf("адрес: %s - not ok (ошибка: %v)", url, err)
	//			continue // продолжаем запросы
	//		}
	//
	//		if resp.StatusCode == http.StatusOK {
	//			resultUrl <- fmt.Sprintf("адрес: %s - ok", url)
	//		} else {
	//			resultUrl <- fmt.Sprintf("адрес: %s - not ok", url)
	//		}
	//		resp.Body.Close()
	//	}
	//}

	/*4. (необязательно, можно обсудить устно, чтобы убедиться, что кандидат понимает идею
	  контекста, либо предложить как домашнее задание) Модифицируйте программу таким
	  образом, что бы при получении 2 первых ответов с "200 OK" остальные запросы штатно
	  прерывались.
	  При этом необходимо напечатать на экране сообщение о завершении запроса.*/

}
